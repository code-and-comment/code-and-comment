!function(){"use strict";let e=null;function t(e){const t=e.target.result.createObjectStore("CodeAndComment",{keyPath:"id",autoIncrement:!0});["git","repository","path"].forEach(e=>{t.createIndex(e,[e,"updated_at"],{unique:!1,multiEntry:!1})}),t.createIndex("updated_at",["updated_at"],{unique:!1,multiEntry:!1})}function n(){if(e)return e;return new Promise((n,r)=>{const o=indexedDB.open("CodeAndComment",1);o.addEventListener("upgradeneeded",t),o.addEventListener("success",t=>{e=t.target.result,n(e)}),o.addEventListener("error",()=>{alert("indexedDB open error"),r(null)})})}function r(e){return e.transaction(["CodeAndComment"],"readwrite").objectStore("CodeAndComment")}function o(e,t="updated_at",n,r="prev",o=!1){return new Promise((a,d)=>{const i=e.index(t).openCursor(n,r),u=[];i.addEventListener("success",e=>{const t=e.target.result;t?(o||delete t.value.lines,u.push(t.value),t.continue()):a(u)}),i.addEventListener("error",()=>{d(null)})})}async function a(e,t,n,r,o=IDBKeyRange.bound,a="prev",d=!1){const i=function(e){let{repository:t}=e;return(t=t&&t.trim())?"repository":"updated_at"}(e),u=function(e,t){let{repository:n}=e;if(n=n&&n.trim())return t([n,new Date(0)],[n,new Date])}(e,o),s=await t(),c=await n(s);return await r(c,i,u,a,d)}self.addEventListener("message",(async function(e){const t=e.data,d=await a({repository:t},n,r,o);self.postMessage(d)}),!1)}();