!function(){"use strict";let e=null;function t(e){const t=e.target.result.createObjectStore("CodeAndComment",{keyPath:"id",autoIncrement:!0});["git","repository","path"].forEach(e=>{t.createIndex(e,[e,"updated_at"],{unique:!1,multiEntry:!1})}),t.createIndex("updated_at",["updated_at"],{unique:!1,multiEntry:!1})}function n(){if(e)return e;return new Promise((n,r)=>{const o=indexedDB.open("CodeAndComment",1);o.addEventListener("upgradeneeded",t),o.addEventListener("success",t=>{e=t.target.result,n(e)}),o.addEventListener("error",()=>{alert("indexedDB open error"),r(null)})})}function r(e){return e.transaction(["CodeAndComment"],"readwrite").objectStore("CodeAndComment")}function o(e,t="updated_at",n,r="prev",o=null){return new Promise((a,u)=>{const i=e.index(t).openCursor(n,r),d=[];i.addEventListener("success",e=>{const t=e.target.result;t?(o&&o(t),d.push(t.value),t.continue()):a(d)}),i.addEventListener("error",()=>{u(null)})})}function a(e){e.value.lines=[]}async function u(e,t,n,r,o=IDBKeyRange.bound,u="prev",i=a){const d=function(e){let{repository:t}=e;return(t=t&&t.trim())?"repository":"updated_at"}(e),s=function(e,t){let{repository:n}=e;if(n=n&&n.trim())return t([n,new Date(0)],[n,new Date])}(e,o),c=await t(),l=await n(c);return await r(l,d,s,u,i)}self.addEventListener("message",(async function(e){const t=e.data,a=await u({repository:t},n,r,o);self.postMessage(a)}),!1)}();