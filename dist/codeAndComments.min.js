!function(){"use strict";let e=null;function t(e){const t=e.target.result.createObjectStore("CodeAndComment",{keyPath:"id",autoIncrement:!0});["git","repository","path"].forEach(e=>{t.createIndex(e,[e,"updated_at"],{unique:!1,multiEntry:!1})}),t.createIndex("updated_at",["updated_at"],{unique:!1,multiEntry:!1})}function n(){if(e)return e;return new Promise((n,r)=>{const a=indexedDB.open("CodeAndComment",1);a.addEventListener("upgradeneeded",t),a.addEventListener("success",t=>{e=t.target.result,n(e)}),a.addEventListener("error",()=>{alert("indexedDB open error"),r(null)})})}function r(e){return e.transaction(["CodeAndComment"],"readwrite").objectStore("CodeAndComment")}function a(e,t="updated_at",n,r="prev",a=!1){return new Promise((o,s)=>{const i=e.index(t).openCursor(n,r),u=[];i.addEventListener("success",e=>{const t=e.target.result;if(t){if(a||Object.keys(t.value.comments).length){const e=Array.from({length:t.value.lines.length});Object.keys(t.value.comments).forEach(n=>{e[n-=0]=t.value.lines[n]}),t.value.lines=e}else t.value.lines=[];u.push(t.value),t.continue()}else o(u)}),i.addEventListener("error",()=>{s(null)})})}async function o(e,t,n,r,a=IDBKeyRange.bound,o="prev",s=!1){const i=function(e){let{repository:t}=e;return(t=t&&t.trim())?"repository":"updated_at"}(e),u=function(e,t){let{repository:n}=e;if(n=n&&n.trim())return t([n,new Date(0)],[n,new Date])}(e,a),d=await t(),c=await n(d);return await r(c,i,u,o,s)}self.addEventListener("message",(async function(e){const t=e.data,s=await o({repository:t},n,r,a);self.postMessage(s)}),!1)}();